<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>执行编译重要概念</title>
</head>
<body>
    <script>
        //  V8引擎执行js代码过程， js代码段通过词法分析 -> 语法分析 -> 语法树，就可以开始解释执行

        // 1、词法分析，将字符流(char stream)转换为记号流(token stream)
        // 2、语法分析，将生成的这些 token 数据，根据一定的语法规则转化为AST
        //    如果分析遇到一个语法错误，就会抛出一个语法错误（syntaxError），停止js代码的执行，然后继续查找并加载下一个代码块；如果语法正确，则生成AST进入预编译阶段
        // 3、预编译，根据语法分析创建一个执行上下文，执行上下文包含变量环境；函数声明，将其添加到变量环境中并将其值设为函数的引用，遇到var变量声明name，将其添加到变量环境中并将其值设为undefined
        //    所有声明的变量和函数进行处理！并且是先预声明变量，再预定义函数！（执行上下文），除声明代码以外的其他代码段将被编译成可执行字节码并保存在内存中
        // 4、将 AST 转换为字节码
        // 5、由解释器逐行执行字节码（逐行解释成机器码执行），遇到热点代码启动编译器（JIT）进行编译，生成对应的机器码复用（字节码 => 机器码）, 以优化执行效率
        // 6、执行过程，执行上下文会被压入一个后进先出的栈结构中——调用栈(Call Stack)，包含变量环境和词法环境，执行可执行的字节码（除声明外的代码）
        //    变量环境里面初始化了当前执行上下文环境的所有var变量声明,let、const声明的变量和函数声明放到词法环境中去
        //    在创建变量环境的阶段，当遇到同名声明是分两种情况处理: 遇到同名函数声明，将变量环境中函数引用指向新的函数代码；遇到同名变量声明，跳过该声明。
        //    JS引擎会将let/const放入一个块级数据结构中且值赋为undefined，然后压入词法环境中。看到let声明的代码块{let/const}，JS引擎新建一个块级词法环境，执行后出栈，词法环境是一种后进先出的栈结构
        //    可执行代码，先在词法环境栈中从上到下找变量或函数声明的地址，没有找到则取变量环境中找，执行



        
        //  JavaScript执行的过程中，主要有三种内存空间：代码空间、堆空间、栈空间。（全局执行上下文只有在应用程序关闭时出栈销毁（关闭页面）--全局变量在整个运行过程都可以访问）
        // 代码空间用来存放编译过程中产生的可执行代码
        // 堆空间用来存放非原始数据类型的数据，即对象及其子类型(数组、集合等)。
        // 栈空间用来存放执行上下文。栈中只会存放原始数据类型的数据。若执行上下文中某变量x为引用类型Object对象，在变量环境（或词法环境）中该变量x的值只是该对象的一个引用地址。

        //  几个重要的概念：执行上下文、变量环境、词法环境、词法作用域、作用域链

    </script>
</body>
</html>