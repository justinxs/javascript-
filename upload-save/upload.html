<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>upload-download</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        ul, ol, dl {
            list-style: none;
        }
        .n-hidden {
            display: none;
        }
        .n-show {
            display: block;
        }
        .container {
            width: 100%;
            height: 300px;
            line-height: 300px;
            text-align: center;
            font-size: 30px;
            background-color: skyblue;
            cursor: pointer;
        }

        .preview ul::after {
            content: "";
            display: block;
            height: 0;
            clear: both;
            visibility: hidden;
        }
        .preview ul li {
            width: 100px;
            float: left;
            padding: 10px;
        }
        .preview ul li img{
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container" id="container" title="ä¸Šä¼ ">æ–‡ä»¶æ‹–æ”¾åŒºåŸŸ</div>
    <div class="preview n-hidden"></div>
    <input class="n-hidden" type="file" name="upload" id="upload" multiple="multiple" accept="image/*">

    <!-- Blob, File, FileReader & URL polyfill -->
    <script src="./Blob.js"></script>
    <script>
        
        const TYPE = ['JPEG', 'TIFF', 'RAW', 'BMP', 'PNG', 'WEBP'];
        const SIZE = 3 * 1024 * 1024;

        document.querySelector('#upload').addEventListener('change', fileChange);

        dropFileHandle(document.querySelector('.container'));

        document.querySelector('.container').addEventListener('click', function (e) {
            console.log('ssss');
            document.querySelector('#upload').click()
        })
        //  ä¸Šä¼ å›¾ç‰‡
        function fileChange(e) {
            let fileList = [...e.target.files];
            Promise.all(fileList.map(file => fileAsImg(file))).then(reArr => getPreviewDom(reArr))
            // saveFile(fileList[0], fileList[0].name.split('.')[0])
            saveFile('https://desk-fd.zol-img.com.cn/t_s4096x2160c5/g5/M00/0C/0A/ChMkJ1apsSmIODmhACxlzomhVCkAAHxjwPCxV8ALGXm886.jpg')

            
            if (getAllowTips(fileList)) return alert(getAllowTips(fileList));

            Promise.all(fileList.map(file => imgZip(file, {q: 1}))).then(reArr => {
                reArr.forEach(data => {
                    if (data.code === 1) {
                        console.log(data.data);
                        // saveFile(data.data.base64, data.data.name.split('.')[0]).then(blob => console.log(blob))
                    } else {
                        console.error(data.msg)
                    }
                })
                
            })
            e.target.value = null;
        }

        function dropFileHandle(container) {
            /* å¯æ‹–åŠ¨çš„ç›®æ ‡å…ƒç´ ä¼šè§¦å‘äº‹ä»¶ */
            container.addEventListener("drag", function(e) {
                e.preventDefault(); 
            }, false);
            container.addEventListener("dragstart",function(e){  //æ‹–ç¦»   
                e.preventDefault();      
            })  
            container.addEventListener("dragleave",function(e){  //æ‹–åæ”¾   
                e.preventDefault();      
            })  
            container.addEventListener("dragenter",function(e){  //æ‹–è¿›  
                e.preventDefault();      
            })  
            container.addEventListener("dragover",function(e){  //æ‹–æ¥æ‹–å»    
                e.preventDefault();      
            })  

            container.addEventListener("drop", function( event ) {
                // é˜»æ­¢é»˜è®¤åŠ¨ä½œï¼ˆå¦‚æ‰“å¼€ä¸€äº›å…ƒç´ çš„é“¾æ¥ï¼‰
                event.preventDefault();

                let fileList = [...event.dataTransfer.files];
                if (getAllowTips(fileList)) return alert(getAllowTips(fileList));

                let promiseArr = fileList.map(file => fileAsImg(file));
                
                Promise.all(promiseArr).then(reArr => {
                    getPreviewDom(reArr)
                })
                // saveFile(fileList[0], fileList[0].name.split('.')[0])

            
            }, false);
        }
        
        /**
         * ç”¨äºåˆ›å»º URL çš„ File å¯¹è±¡ã€Blob å¯¹è±¡æˆ–è€… MediaSource å¯¹è±¡å¹¶è½¬img,ç”¨äºå‰ç«¯é¢„è§ˆæ–‡ä»¶
         * @method fileAsImg
         * @param {Object} file æ–‡ä»¶ [object File] [object Blob] [object MediaSource](è§†é¢‘)
         * @return {Promise} è¿”å›ä¸€ä¸ªpromiseå¯¹è±¡ï¼ŒæˆåŠŸå¾—åˆ°ä¸€ä¸ªdomå¯¹è±¡ img
         */
        function fileAsImg(file) {
            let objectURL = window.URL.createObjectURL(file);
            return loadImg(objectURL).then(data => {
                console.log(objectURL);
                window.URL.revokeObjectURL(objectURL);
                return data.data
            })
        }

        /**
         * é¢„è§ˆå›¾ç‰‡
         * @method getPreviewDom
         * @param {Array} imageåˆ—è¡¨ [img, img]
         */
        function getPreviewDom(data) {
            let parent = document.querySelector('.preview');
            let ul = document.createElement('ul')
            data.forEach(img => {
                let item = document.createElement('li');
                item.appendChild(img);
                ul.appendChild(item)
            })
            parent.appendChild(ul);
            parent.classList.remove('n-hidden');
            parent.classList.add('n-show');
        }

        function getAllowTips(fileList) {
            let result = '';
            const allowCollection = {
                isEmpty: {
                    flag: !fileList.length, 
                    msg: `ä¸Šä¼ ä¸ºç©º`
                },
                isAllowType: {
                    flag: fileList.some(file => TYPE.indexOf(file.type.split('/')[1].toUpperCase()) === -1), 
                    msg: `ä»…æ”¯æŒ${TYPE.map(type => `image/${type.toLowerCase()}`).join('ã€')}æ–‡ä»¶ï¼Œ
                    ${fileList.filter(file => TYPE.indexOf(file.type.split('/')[1].toUpperCase()) === -1).map(file => `æ–‡ä»¶ ${file.name}ç±»å‹ä¸º ${file.type}`).join('ã€')}`
                },
                isAllowSize: {
                    flag: fileList.some(file => file.size > SIZE), 
                    msg: `å•ä¸ªæ–‡ä»¶æœ€å¤§æ”¯æŒ${SIZE}Byte, 
                    ${fileList.filter(file => file.size > SIZE).map(file => `æ–‡ä»¶${file.name} å¤§å°ä¸º ${file.size}Byte`).join('ã€')}`
                },
            }
            for (const key in allowCollection) {
                if (allowCollection.hasOwnProperty(key) && allowCollection[key].flag) {
                    result = allowCollection[key].msg;
                    break;
                }
            }
            return result
        }

        function uploadFile(file, url, {success, error, progress}) {
            let xhr = createXMLHttp(),
            msgObj = {progress: 0, finish: false, data: null};
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4 && xhr.status == 200){
                    let res = JSON.parse(xhr.responseText);
                    msgObj.data = res;
                    msgObj.progress = 1;
                    msgObj.finish = true;
                    success && success(msgObj)
                } else {
                    error && error(msgObj)
                }
            }
            xhr.upload.onprogress = function (e) {
                if (e.lengthComputable) {
                    msgObj.progress = parseInt(e.loaded / e.total);
                    progress && progress(msgObj)
                } else {
                    console.error('æ€»å¤§å°æœªçŸ¥æ—¶ä¸èƒ½è®¡ç®—è¿›ç¨‹ä¿¡æ¯')
                }
            }
            xhr.onerror = function (e) {
                msgObj.progress = -1;
                msgObj.finish = false;
                error && error(e);
            }
            xhr.open("POST", url, true);
            xhr.setRequestHeader("Content-Type", "application/octet-stream");
            xhr.send(file);
            
            return msgObj
        }

        
        /**
         * å›¾ç‰‡å¤§å°å‹ç¼© 
         * @method  imgZip
         * @for æ‰€å±ç±»å
         * @param {Object} file å›¾ç‰‡æ–‡ä»¶ [object File] [object Blob]
         * @param {String} type è¾“å‡ºå›¾ç‰‡æ ¼å¼ï¼Œé»˜è®¤å€¼ image/png
         * @param {Number} q åœ¨æŒ‡å®šå›¾ç‰‡æ ¼å¼ä¸º image/jpeg æˆ– image/webpçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ä» 0 åˆ° 1 çš„åŒºé—´å†…é€‰æ‹©å›¾ç‰‡çš„è´¨é‡ã€‚å¦‚æœè¶…å‡ºå–å€¼èŒƒå›´ï¼Œå°†ä¼šä½¿ç”¨é»˜è®¤å€¼ 0.92ã€‚å…¶ä»–å‚æ•°ä¼šè¢«å¿½ç•¥
         * @return {Promise} è¿”å›ä¸€ä¸ªpromiseå¯¹è±¡ï¼ŒæˆåŠŸå¾—åˆ°ä¸€ä¸ªå¯¹è±¡ {code: 1, data}
         * 
         * æ³¨ï¼šç”±äºå‹ç¼©åªèƒ½image/jpeg æˆ– image/webpæ ¼å¼çš„å›¾ç‰‡ç”Ÿæ•ˆï¼Œå¦‚æœä¼ å…¥çš„å›¾ç‰‡ä¸æ˜¯è¿™ä¸¤ä¸ªæ ¼å¼ï¼Œåˆ™å¼ºåˆ¶è½¬æˆimage/jpegè¾“å‡º
         */
        function imgZip(file, {q, type}) {
            const functionalType = ['image/jpeg', 'image/webp'];

            return fileAsBase64(file)
            .then(re => {
                return loadImg(re.data.url).then(imgData => {
                    let name = re.data.name,
                    inputType = re.data.type || ('image/' + name.split('.')[1]),
                    outputType = (~functionalType.indexOf(type) && type) || (~functionalType.indexOf(inputType) && inputType) || functionalType[0],
                    outputQ = q || 0.92,
                    originSize = re.data.originSize,
                    w = imgData.data.width,
                    h = imgData.data.height,
                    base64 = canvasAsBase64(imgAsCanvas(imgData.data), outputType, outputQ),
                    outputSize = getBase64Content(base64).size;

                    return {
                        code: 1,
                        data: {name, inputType, outputType, outputQ, originSize, w, h, base64, outputSize}
                    }
                })
            }).catch(error => error)

        }

        /**
         * æ–‡ä»¶è½¬base64æ ¼å¼
         * @method fileAsBase64
         * @param {Object} file æ–‡ä»¶ [object File] [object Blob]
         * @return {Promise} è¿”å›ä¸€ä¸ªpromiseå¯¹è±¡ï¼ŒæˆåŠŸå¾—åˆ°ä¸€ä¸ªå¯¹è±¡ {code: 1, data}
         */
        function fileAsBase64(file) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function (e) {
                    resolve({
                        code: 1, 
                        data: {
                            name: file.name,
                            type: file.type,
                            originSize: file.size,
                            url: e.target.result
                        }
                    })
                }
                reader.onerror = function (e) {
                    reject({code: 0, msg : 'can not readFile'})
                }
            })
        }

        /**
         * å›¾ç‰‡ç»˜åˆ¶åœ¨canvasç”»å¸ƒä¸Š
         * @method imgAsCanvas
         * @param {DOM} img å·²åŠ è½½å®Œæ¯•çš„å›¾ç‰‡å…ƒç´ DOMèŠ‚ç‚¹,æˆ–è€…ä¸€ä¸ªcanvas
         * @return {DOM} è¿”å›ä¸€ä¸ªç»˜åˆ¶å¥½çš„canvas
         */
        function imgAsCanvas(img) {
            let canvas = document.createElement('canvas'),
            context = canvas.getContext('2d');
            canvas.height =  img.height;
            canvas.width = img.width;
            context.drawImage(img, 0, 0, img.width, img.height);
            return canvas
        }

        /**
         * canvasè½¬base64
         * @method canvasAsBase64
         * @param {DOM} canvas canvas DOMèŠ‚ç‚¹
         * @param {String} type è¾“å‡ºçš„å›¾ç‰‡ç±»å‹ï¼Œé»˜è®¤å€¼ image/png
         * @param {Number} q è¾“å‡ºçš„å›¾ç‰‡è´¨é‡ï¼Œé»˜è®¤å€¼1
         * @return {DOMString} DataURI 
         */
        function canvasAsBase64(canvas, type = 'image/png', q = 1) {
            return canvas.toDataURL(type, q)
        }


        /**
         * canvasè½¬Blob
         * @method canvasAsBlob
         * @param {DOM} canvas canvas DOMèŠ‚ç‚¹
         * @param {String} type è¾“å‡ºçš„å›¾ç‰‡ç±»å‹ï¼Œé»˜è®¤å€¼ image/png
         * @param {Number} q è¾“å‡ºçš„å›¾ç‰‡è´¨é‡ï¼Œé»˜è®¤å€¼1
         * @return {Promise} æˆåŠŸè¿”å›Blob æ–‡ä»¶å¯¹è±¡ 
         */

        function canvasAsBlob(canvas, type = 'image/png', q = 1) {
            return new Promise((resolve, reject) => {
                if (!HTMLCanvasElement.prototype.toBlob) {
                    let dataURI = canvasAsBase64(canvas, type, q);
                    return resolve(base64AsBlob(dataURI, type))
                } else {
                    return canvas.toBlob(resolve, type, q);
                }
            })
        }
        //  ArrayBuffer => Base64
        function arrayBufferToBase64(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            var len = bytes.byteLength;
            for (var i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        //  Base64 => ArrayBuffer
        function base64ToArrayBuffer(base64) {
            var binary_string = window.atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        //  buffer => ArrayBuffer
        function toArrayBuffer(buf) {
            var ab = new ArrayBuffer(buf.length);
            var view = new Uint8Array(ab);
            for (var i = 0; i < buf.length; ++i) {
                view[i] = buf[i];
            }
            return ab;
        }

        //  ArrayBuffer => buffer
        function toBuffer(ab) {
            var buf = new Buffer(ab.byteLength);
            var view = new Uint8Array(ab);
            for (var i = 0; i < buf.length; ++i) {
                buf[i] = view[i];
            }
            return buf;
        }

        //  å­—ç¬¦ä¸²è½¬æ¢ä¸ºåå…­è¿›åˆ¶
        //  str => ASCII å­—ç¬¦ç¼–ç (Number) => 16è¿›åˆ¶æ•°å­—
        function stringToHex(str){
        ã€€ã€€var val = "", tempHex = '';
        ã€€ã€€for(var i = 0; i < str.length; i++){
                tempHex = str.charCodeAt(i).toString(16);
                val += val === '' ? tempHex : "," + tempHex;
        ã€€ã€€}
        ã€€ã€€return val;
        }
        //  åå…­è¿›åˆ¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        //  16è¿›åˆ¶æ•°å­— => str
        function hexToString(str){
        ã€€ã€€ã€€var val = "";
        ã€€ã€€ã€€var arr = str.split(",");
        ã€€ã€€ã€€for(var i = 0; i < arr.length; i++){
        ã€€ã€€ã€€ã€€ã€€val += arr[i].fromCharCode(i);
        ã€€ã€€ã€€}
        ã€€ã€€ã€€return val;
        }

        // This is the same for all of the below, and
        // you probably won't need it except for debugging
        // in most cases.
        function bytesToHex(bytes) {
            return Array.from(
                bytes,
                byte => byte.toString(16).padStart(2, "0")
            ).join("");
        }

        // You almost certainly want UTF-8, which is
        // now natively supported:
        function stringToUTF8Bytes(string) {
            return new TextEncoder().encode(string);
        }

        // But you might want UTF-16 for some reason.
        // .charCodeAt(index) will return the underlying
        // UTF-16 code-units (not code-points!), so you
        // just need to format them in whichever endian order you want.
        function stringToUTF16Bytes(string, littleEndian) {
            const bytes = new Uint8Array(string.length * 2);
            // Using DataView is the only way to get a specific
            // endianness.
            const view = new DataView(bytes.buffer);
        for (let i = 0; i != string.length; i++) {
            view.setUint16(i, string.charCodeAt(i), littleEndian);
        }
        return bytes;
        }

        // And you might want UTF-32 in even weirder cases.
        // Fortunately, iterating a string gives the code
        // points, which are identical to the UTF-32 encoding,
        // though you still have the endianess issue.
        function stringToUTF32Bytes(string, littleEndian) {
            const codepoints = Array.from(string, c => c.codePointAt(0));
            const bytes = new Uint8Array(codepoints.length * 4);
            // Using DataView is the only way to get a specific
            // endianness.
            const view = new DataView(bytes.buffer);
            for (let i = 0; i != codepoints.length; i++) {
                view.setUint32(i, codepoints[i], littleEndian);
            }
            return bytes;
        }

        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i !== bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        }

        function bytesToStringUTF32(bytes, littleEndian) {
            const view = new DataView(bytes.buffer);
            const codepoints = new Uint32Array(view.byteLength / 4);
            for (let i = 0; i !== codepoints.length; i++) {
                codepoints[i] = view.getUint32(i * 4, littleEndian);
            }
            return String.fromCodePoint(...codepoints);
        }
        
        bytesToHex(stringToUTF8Bytes("hello æ¼¢å­— ğŸ‘"))
        // "68656c6c6f20e6bca2e5ad9720f09f918d"
        bytesToHex(stringToUTF16Bytes("hello æ¼¢å­— ğŸ‘", false))
        // "00680065006c006c006f00206f225b570020d83ddc4d"
        bytesToHex(stringToUTF16Bytes("hello æ¼¢å­— ğŸ‘", true))
        // "680065006c006c006f002000226f575b20003dd84ddc"
        bytesToHex(stringToUTF32Bytes("hello æ¼¢å­— ğŸ‘", false))
        // "00000068000000650000006c0000006c0000006f0000002000006f2200005b57000000200001f44d"
        bytesToHex(stringToUTF32Bytes("hello æ¼¢å­— ğŸ‘", true))
        // "68000000650000006c0000006c0000006f00000020000000226f0000575b0000200000004df40100"


        // UTF-8 is default
        // "hello æ¼¢å­— ğŸ‘"
        new TextDecoder().decode(hexToBytes("68656c6c6f20e6bca2e5ad9720f09f918d"));
        // but you can also use:
        new TextDecoder("UTF-16LE").decode(hexToBytes("680065006c006c006f002000226f575b20003dd84ddc"))
        new TextDecoder("UTF-16BE").decode(hexToBytes("00680065006c006c006f00206f225b570020d83ddc4d"));


        // "hello æ¼¢å­— ğŸ‘"
        console.log(bytesToStringUTF32(hexToBytes("00000068000000650000006c0000006c0000006f0000002000006f2200005b57000000200001f44d"), false));
        console.log(bytesToStringUTF32(hexToBytes("68000000650000006c0000006c0000006f00000020000000226f0000575b0000200000004df40100"), true));
        

        /**
         * base64 è½¬blobæ–‡ä»¶æµ
         * @method base64AsBlob
         * @param {DOMString} dataURI base64æ–‡ä»¶å­—ç¬¦ä¸²
         * @param {String} mimeType è¾“å‡ºçš„MIMEç±»å‹
         * @return {Object} æˆåŠŸè¿”å›Blob æ–‡ä»¶å¯¹è±¡ 
         */

        function base64AsBlob(dataURI, mimeType) {
            let base64Msg = getBase64Content(dataURI),
            base64Content = base64Msg.content,
            type = mimeType || base64Msg.mimeType,
            fileSize = base64Msg.size;
            
            if (window.atob) {
                let byteString = window.atob(base64Content),
                ab = new ArrayBuffer(byteString.length),
                ia = new Uint8Array(ab);

                for (var i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                return new Blob([ab], { type });
            } else {
                let len = base64Content.length
                , buffer = new Uint8Array(len / 4 * 3 | 0)
			    , i = 0
			    , outptr = 0
			    , last = [0, 0]
			    , state = 0
                , save = 0
                , base64_ranks = new Uint8Array([
		              62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1
		            , -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9
		            , 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
		            , -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
		            , 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
	            ])
			    , rank
			    , code
                , undef;
                
		        while (len--) {
		        	code = base64Content.charCodeAt(i++);
		        	rank = base64_ranks[code-43];
		        	if (rank !== 255 && rank !== undef) {
		        		last[1] = last[0];
		        		last[0] = code;
		        		save = (save << 6) | rank;
		        		state++;
		        		if (state === 4) {
		        			buffer[outptr++] = save >>> 16;
		        			if (last[1] !== 61 /* padding character */) {
		        				buffer[outptr++] = save >>> 8;
		        			}
		        			if (last[0] !== 61 /* padding character */) {
		        				buffer[outptr++] = save;
		        			}
		        			state = 0;
		        		}
		        	}
                }

                return new Blob([buffer], { type });
            }
           
        }

        /**
         * å¤„ç†base64æ•°æ®
         * @method getBase64Content
         * @param {DOMString} dataURI base64æ–‡ä»¶å­—ç¬¦ä¸²
         * @return {Object} mimeType æ–‡ä»¶ç±»å‹ï¼Œ sizeæ–‡ä»¶å¤§å°ï¼Œ contentæ–‡ä»¶å†…å®¹
         */

        function getBase64Content(dataURI) {
            const base64Reg = /^data:([\S]+);base64,/;
            if (!dataURI || !base64Reg.test(dataURI)) return console.error('dataURI is not define or dataURI is not DataURI')
            return {
                mimeType: base64Reg.exec(dataURI)[1] || '',
                size: dataURI.replace(base64Reg, '').length / 4 * 3 | 0,
                content: dataURI.replace(base64Reg, '')
            }
        }

        /**
         * å¼‚æ­¥åŠ è½½å›¾ç‰‡
         * @method loadImg
         * @param {String} url å›¾ç‰‡åœ°å€
         * @param {Boolean} crossOrigin æ˜¯å¦è®¾ç½®è·¨åŸŸ
         * @return {Promise} æˆåŠŸè¿”å›ä¸€ä¸ªåŠ è½½å®Œçš„img DOM
         */

        function loadImg(url, crossOrigin = false) {
            return new Promise((resolve, reject) => {
                let img = new Image();
                crossOrigin && (img.crossOrigin = 'anonymous');
                img.onload = function (e) {
                    resolve({code: 1, data: img})
                }
                img.onabort = function (e) {
                    reject({code: 0, msg : 'can not load image'})
                }
                img.onerror = function (e) {
                    reject({code: 0, msg : 'can not load image'})
                }
                img.src = url
            })
        }

        /**
         * é€šè¿‡XMLHttpRequest å¼‚æ­¥è·å–ç‰¹å®šç±»å‹çš„å“åº”æ•°æ®
         * @method getStaticFile
         * @param {String} url èµ„æºåœ°å€
         * @param {String} type 
         *  ""	            å°† responseType è®¾ä¸ºç©ºå­—ç¬¦ä¸²ä¸è®¾ç½®ä¸º"text"ç›¸åŒï¼Œ æ˜¯é»˜è®¤ç±»å‹ ï¼ˆå®é™…ä¸Šæ˜¯ DOMStringï¼‰ã€‚
         *  "arraybuffer"	response æ˜¯ä¸€ä¸ªåŒ…å«äºŒè¿›åˆ¶æ•°æ®çš„ JavaScript ArrayBuffer ã€‚
         *  "blob"	        response æ˜¯ä¸€ä¸ªåŒ…å«äºŒè¿›åˆ¶æ•°æ®çš„ Blob å¯¹è±¡ ã€‚
         *  "document"	    response æ˜¯ä¸€ä¸ª HTML Document æˆ– XML XMLDocument ï¼Œè¿™å–å†³äºæ¥æ”¶åˆ°çš„æ•°æ®çš„ MIME ç±»å‹ã€‚
         *  "json"	        response æ˜¯ä¸€ä¸ª JavaScript å¯¹è±¡ã€‚è¿™ä¸ªå¯¹è±¡æ˜¯é€šè¿‡å°†æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹è§†ä¸º JSON è§£æå¾—åˆ°çš„ã€‚
         *  "text"	        response æ˜¯åŒ…å«åœ¨ DOMString å¯¹è±¡ä¸­çš„æ–‡æœ¬ã€‚
         * @return {Promise} æˆåŠŸè¿”å›{code: 1, data}
         * 
         * æ³¨ï¼šåœ¨å·¥ä½œç¯å¢ƒ(Work Environment)ä¸­å°†responseTypeçš„å€¼è®¾ç½®ä¸º"document"é€šå¸¸ä¼šè¢«å¿½ç•¥. 
         * å½“å°†responseTypeè®¾ç½®ä¸ºä¸€ä¸ªç‰¹å®šçš„ç±»å‹æ—¶ï¼Œä½ éœ€è¦ç¡®ä¿æœåŠ¡å™¨æ‰€è¿”å›çš„ç±»å‹å’Œä½ æ‰€è®¾ç½®çš„è¿”å›å€¼ç±»å‹æ˜¯å…¼å®¹çš„ã€‚
         * é‚£ä¹ˆå¦‚æœä¸¤è€…ç±»å‹ä¸å…¼å®¹å‘¢?
         * æ­å–œä½ ï¼Œä½ ä¼šå‘ç°æœåŠ¡å™¨è¿”å›çš„æ•°æ®å˜æˆäº†nullï¼Œå³ä½¿æœåŠ¡å™¨è¿”å›äº†æ•°æ®ã€‚
         * è¿˜æœ‰ä¸€ä¸ªè¦æ³¨æ„çš„æ˜¯ï¼Œç»™ä¸€ä¸ªåŒæ­¥è¯·æ±‚è®¾ç½®responseTypeä¼šæŠ›å‡ºä¸€ä¸ªInvalidAccessError çš„å¼‚å¸¸
         */

        function getStaticFile(url, type = '') {
            return new Promise((resolve, reject) => {
                let xhr = createXMLHttp();
                xhr.onload = function () {
                    if (this.response) {
                        resolve({code: 1, data: this.response})
                    } else {
                        reject({code: 0, data: url, msg: 'æœåŠ¡å™¨æ‰€è¿”å›çš„ç±»å‹å’Œä½ æ‰€è®¾ç½®çš„è¿”å›å€¼ç±»å‹ä¸å…¼å®¹'})
                    }
                }
                xhr.onerror = function (error) {
                    reject(error)
                }
                xhr.open('GET', url, true);
                xhr.responseType = type;
                xhr.send();
            })
        }

        
        /**
         * æµè§ˆå™¨å¼‚æ­¥ä¸‹è½½æ–‡ä»¶
         * @method saveFile
         * @param {File|Blob|DOMString|String} file æ–‡ä»¶[object File] [object Blob] DataURI æˆ–è€…æ–‡ä»¶åœ°å€url
         * @param {String} name æ–‡ä»¶åç§°
         * @param {String} fileType æ–‡ä»¶ç±»å‹ image/png image/jpeg
         * @return {Promise} æˆåŠŸè¿”å›ä¸€ä¸ªBlobå¯¹è±¡
         */
        function saveFile(file, name, fileType) {
            const base64Reg = /^data:([\S]+);base64,/,
            //  ie ie11 edge
            regex = /(?:ms|\()(ie)\s([\w\.]+)|trident|(edge|edgios|edga|edg)/i,
            isDataURI = base64Reg.test(file),
            ieKit = regex.test(window.navigator.userAgent),
            type = ({}).toString.call(file),
            isBlob = type === "[object Blob]",
            isFile = type === "[object File]";
            
            console.log(type, isBlob, isFile);
            let filename = name || 'download';

            let getDataPromise = new Promise((resolve, reject) => {
                let result = (isBlob || isFile) 
                ? file 
                : isDataURI ? base64AsBlob(file) : getStaticFile(file, 'blob').then(data => data.data);

                return resolve(result)
            })

            return getDataPromise.then(data => {
                filename += '.' + (data.type ? data.type.split('/')[1] : 'png');

                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(data, filename)
                } else {
                    let objectURL = window.URL.createObjectURL(data),
                    save_link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a'),
                    event = document.createEvent('MouseEvents');

                    save_link.href = objectURL;
                    save_link.download = filename;
                    event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    save_link.dispatchEvent(event);

                    window.URL.revokeObjectURL(objectURL);
                }
                return data
            }).catch(console.error)
        }

        /**
         * å…¼å®¹åˆ›å»ºXMLHttpRquestå¯¹è±¡
         * @method createXMLHttp
         * @return {Object} xhr
         */

        function createXMLHttp() {
            let xmlhttp;
			try {
				xmlhttp = new XMLHttpRequest(); //å°è¯•åˆ›å»º XMLHttpRequest å¯¹è±¡ï¼Œé™¤ IE å¤–çš„æµè§ˆå™¨éƒ½æ”¯æŒè¿™ä¸ªæ–¹æ³•ã€‚
			} catch (e) {
				try {
					xmlhttp = ActiveXobject('Msxml12.XMLHTTP'); //ä½¿ç”¨è¾ƒæ–°ç‰ˆæœ¬çš„ IE åˆ›å»º IE å…¼å®¹çš„å¯¹è±¡ï¼ˆMsxml2.XMLHTTPï¼‰ã€‚
				} catch (ex) {
					try {
						xmlhttp = ActiveXobject('Microsoft.XMLHTTP'); //ä½¿ç”¨è¾ƒè€ç‰ˆæœ¬çš„ IE åˆ›å»º IE å…¼å®¹çš„å¯¹è±¡ï¼ˆMicrosoft.XMLHTTPï¼‰ã€‚
					} catch (failed) {
						xmlhttp = false; //å¦‚æœå¤±è´¥äº†è¿˜ä¿æŒfalse
					}
				}
			}
			return xmlhttp;
        }

    </script>
</body>
</html>